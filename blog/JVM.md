# 1.类加载机制

## 1.1 类加载过程

类加载过程：
- Load：读取类文件信息产生二进制流，并转化为特定的数据结构
- Link：验证、准备、解析。验证：进行更详细的校验，验证类型是否合理、静态变量是否合规等。准备：静态变量分配内存，并设置默认值。解析：确保类和类之间相互引用的正确性，完成内存分配。
- Init：执行类构造器clinit方法。

## 1.2 双亲委派模型
&emsp;&emsp;双亲委派模型的基本描述是：如果一个类加载器收到类加载的请求，它首先不会尝试加载它，而是把请求传给父类加载器去完成，最终传到启动类加载器。当父类加载器反馈无法加载此类时，子类加载器才尝试自己去加载。

<img src="https://img-blog.csdn.net/20180402141430859?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5naGFubHVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="50%" height="50%">

上述图片中有几个类加载器，具体如下：
1.启动类加载器：负责加载存放JAVA_HOME\lib目录中的类
2.扩展类加载器：负责加载存放JAVA_HOME\lib\etc目录中的类
3.系统类加载器：负责加载用户类路径上所指定的类库

# 2. 内存分配

>* 堆：实例对象和大数组
>* 虚拟机栈：局部变量表、操作栈、方法返回地址
>* 本地方法栈：执行Native方法使用
>* 程序计数器：执行指令的地址
>* 方法区：类信息、常量和静态变量

# 3. 内存回收（GC）

## 3.1 内存回收算法

>* 标记-清除：标记需要回收的对象，标记完成后统一回收，会产生大量碎片。
>* 复制算法：内存分为两块：对其中的一块进行GC时，将其中存活的对象复制到另一块中，对回收的一块内存直接清空。
>* 标记-整理：对内存中存活的对象进行标记，移到一端，对另一端进行清除。

## 3.2 垃圾回收器

>* Serial回收器：YGC垃圾回收器、串行单线程执行GC任务。GC时候会stop the world.
>* CMS回收器：回收停顿时间比较短，是目前比较常用的回收器。可以并发标记和并发清除。
>* G1收集器：局部采用标记-复制算法，总体性能不错。
